# Список правок #


## Колбек на хит актора ##

**[ТЧ/ЧН/ЗП]** Для актора работает колбек на хит. Устанавливать также, как для монстров и сталкеров. Вызывается независимо от того, помер ГГ или нет.

## Колбек на хит объекта прожектора ##

**[ТЧ]** Добавлен колбек на хит объекту прожектора (searchlight). Нужен для реализации разбивания прожектора выстрелом аналогично как это происходит в движке для лампочек.

## Колбеки на клавиши и мышь ##

**[ТЧ/ЧН]** Добавлены колбеки актора на нажатие/удержание/отпускание клавиш а также на вращение мышиного колеса и движение мыши. Коды колбеков:
  * нажатие - 123
  * отпускание - 124
  * удержание - 125
  * кручение колёсика мыши - 126
  * движение мыши - 127

Установка производится также, как и всех других колбеков в биндере: ```
self.object:set_callback(123, self.on_key, self)
...
function actor_binder:on_key(key)
log1("actor_binder:on_key "..key.." "..dik_to_bind(key) )
end``` Снятие: ```
self.object:set_callback(123, nil)``` Аргументы колбеков:

  * для клавиш - коды клавиш, для которых в скриптовом классе **DIK\_keys** есть удобные обозначения. Среди прочего, там есть и коды для мышиных кнопок, т.е. таким образом будут ловиться также мышиные нажатия.
  * для колеса мыши аргумент - скорость вращения + 100000. Т.е. из аргумента надо вычесть 100000, чтобы получить нужное значение. У меня после вычитания всегда выходило +/-120
  * для движения мыши два аргумента - смещения мыши с последнего перемещения, также каждое + 100000. Это не координаты мыши, а выходит больше скорость перемещения.

Для предотвращения вылета при выходе из игры по **Alt+F4** вызов данных колбеков на **Alt** заблокирован совсем. **F4** разрешён только на нажатие.

**[ЗП]** - из списка приведенного выше добавлен лишь один колбек на нажатие (123).

## функция разрешения колбеков ##

**[ТЧ/ЧН]** Добавлена функция разрешения колбеков **set\_extensions\_flags(flags)**.

**flags**- целое значение, набор флажков, каждый из которых отвечает за свой колбек:

  * 1 - нажатие
  * 2 - отпускание
  * 4 - удержание
  * 8 - колёсико
  * 16 - движение мыши

Комбинировать флажки можно с помощью функций побитовой арифметики, а можно и просто складывая (естественно, соблюдая известную аккуратность). Таким образом, чтобы разрешить, скажем, отпускание кнопок и движение мыши надо сделать так: **set\_extensions\_flags(2 + 16).**

Узнать текущее значение набора флагов можно с помощью функции **get\_extensions\_flags**. Используем так:

**local flags = get\_extensions\_flags()**

Использование этих функций строго обязательно! В net\_spawn биндера актора надо разрешить нужные колбеки (иначе они не будут работать), а в net\_destroy - заблокировать ВСЕ колбеки обратно, иначе будет вылет при повторной загрузке.

**[ЗП]** - Функции включение/отключения (set\_extensions\_flags(flags)) в ЗП нет, но никаких проблем в работе колбека не заметил.

## bind\_to\_dik (перевод кода команды в код клавиши) ##

**[ТЧ/ЧН]** Глобальная функция **bind\_to\_dik**, которая переводит код команды в код клавиши. Предназначена для использования совместно с колбеками на нажатие. Если команда равна 79 (для ЧН) или 78 (для ТЧ) (т.е. соответствует неприбинденной клавише), то возвращает 100000. Значения аргумента больше этого значения вызывают вылет.

## функции работы с топливом для машины ##

**[ТЧ/ЧН]** К классу **game\_object** добавлены следующие методы:

**get\_fuel()** -- получить количество топлива<br>
<b>set_fuel(new_value)</b> -- установить количество топлива<br>
<b>get_fuel_tank()</b> -- получить размер бака<br>
<b>get_fuel_consumption()</b> -- получить расход топлива<br>
<b>set_fuel_consumption()</b> -- установить расход топлива<br>

Аргументы и результат - числа с плавающей запятой. Применимы только к машине и дают/устанавливают топливо, потребление и размер бачка. Пользуемся так: <pre><code>-- car_obj - клиентский объект машины<br>
local fuel = car_obj:get_fuel()<br>
car_obj:set_fuel(20.0)</code></pre>

Используя эти функции можно сохранять состояние машины в биндере.<br>
<br>
<h2>получение информации о точке/объекте, куда смотрит актор</h2>

<b>[ТЧ/ЧН/ЗП]</b> Добавлена функция получения расстояния до точки, на которую смотрим (игровой дальномер, который отображается под прицелом):<br>
<br>
<b>level.get_target_dist()</b><br />

<b>[ЧН]</b> Добавлен метод определения объекта, на который смотрит камера. Метод добавлен к классу <b>game_object</b>, так что можно вызывать для любого клиентского объекта, хотя наверное самым разумным будет использовать актора. Пользуемся так:<br>
<br>
<b>local obj = db.actor:get_target_obj()</b><br />

возвращает клиентский объект. Если ни на что не смотрим, то возвращает nil. Объекты без визуала так увидеть невозможно.<br>
<br>
<b>[ТЧ/ЗП]</b> это-же реализовано в виде функции <b>level.get_target_obj()</b>

<h2>затычка от вылета mp_ranks</h2>

<b>[ТЧ/ЧН/ЗП]</b> Сделана затычка для предотвращения вылета при отсутствии ствола в mp_ranks. Не проверено, надо тестировать!<br>
<br>
<h2>получение/установка FOV камеры актора</h2>

<b>[ТЧ]</b> Реализовано методом класса <b>game_object</b>. Значение FOV хранится в глобальной переменной, поэтому годится любой клиентский объект. С другой стороны, всё-таки нужен клиентский объект, поэтому функция недоступна в тот момент, когда ни одного объекта нет, в частности при старте игры до загрузки сохранения. Это был самый быстрый вариант реализации. Если нужен вариант не привязанный к наличию объекта, скажите, я сделаю. Но это потребует дополнительной работы и будет не сразу. Используем так:<br>
<br>
<b>fov = db.actor:get_camera_fov()</b> -- чтение<br>
<br>
<b>db.actor:set_camera_fov(fov)</b> -- установка.<br>
<br>
<b>[ЧН]</b>Для той-же цели добавлены глобальные функции <b>level.get_fov</b> и <b>level.set_fov</b>. Не проверено, надо тестировать! Пользоваться так:<br>
<br>
<b>local fov = level.get_fov()</b> -- получение<br>
<b>level.set_fov(new_fov)</b> -- установка<br>
<br>
<b>[ЗП]</b> добавлена консольная команда fov<br>
<br>
<h2>увеличение максимального количества артефактов на поясе</h2>

<b>[ЧН]</b> Максимальное количество артов на поясе увеличено до 10-и. Не проверено, надо тестировать! Это фактически правка не инвентаря, а брони. Надо протестировать также в режиме апгрейда, поскольку в каждом апгрейде свои лимиты.<br>
<br>
<h2>манипуляции предметами в инвентаре</h2>

<b>[ТЧ/ЧН]</b> Добавлены функции работы с поясом<br>
<br>
<ul><li><b>belt_count</b> (<b>belt_count</b> для ТЧ) -- возвращает количество объектов на поясе<br>
</li><li><b>item_on_belt(index)</b> -- возвращает объект на поясе или nil, если индекс выходит за пределы [0, N-1] индекс считает от нуля.</li></ul>

В целом пользуемся примерно также, как существующими движковыми методами <b>object_count</b> и <b>object</b>: <pre><code>for i=0,db.actor:belt_count()-1 do<br>
log1(""..i.."="..db.actor:item_on_belt(i):section())<br>
end</code></pre>

<b>[ТЧ]</b> Добавлены аналогичные функции для рюкзака: <b>item_in_ruck</b> и <b>ruck_count</b>

<b>[ТЧ]</b> Добавлены колбеки на перемещение предметов в инвентаре:<br>
<br>
<ul><li>на пояс - код 130<br>
</li><li>в рюкзак - код 131<br>
</li><li>в слот - код 132</li></ul>

Колбеки задаются для актора. Единственный аргумент - клиентский объект, который был перемещён. В целом работает примерно как колбек на поднятие.<br>
<br>
Внимание! Колбеки срабатывают также при загрузке игры или уровня при выходе предметов инвентаря в онлайн.<br>
<br>
<b>[ТЧ]</b> Добавлены функции, позволяющие перемещать предметы между рюкзаком, слотами и поясом:<br>
<ul><li><b>move_to_ruck</b> -- переместить в рюкзак<br>
</li><li><b>move_to_belt</b> -- переместить на пояс<br>
</li><li><b>move_to_slot</b> -- переместить в слот (какой именно, определяется секцией предмета)<br>
</li><li><b>move_to_slot_and_activate</b> -- переместить в слот с одновременной активацией</li></ul>

Функции вызываются для клиентского актора: <b>actor:move_to_belt(item)</b>

<b>[ТЧ]</b> Добавлены функции определения местоположения предмета в инвентаре:<br>
<ul><li><b>is_on_belt</b> -- предмет находится на поясе<br>
</li><li><b>is_in_ruck</b> -- предмет в рюкзаке<br>
</li><li><b>is_in_slot</b> -- предмет в слоте<br>
Функции вызываются для клиентского актора: <b>actor:is_in_slot(item)</b></li></ul>

<b>[ТЧ]</b> Добавлены функции, проверяющие возможность перемещать предметы в рюкзак/слот/поясом:<br>
<ul><li><b>can_move_to_slot</b> -- можно переместить в слот<br>
</li><li><b>can_move_to_ruck</b> -- можно переместить в рюкзак (вообще-то можно всегда, добавлено просто для полноты)<br>
</li><li><b>can_move_to_belt</b> -- можно переместить на пояс<br>
Функции вызываются для клиентского актора: <b>actor:can_move_to_belt(item)</b></li></ul>

<h2>универсальный хак для актора</h2>

<b>[ТЧ]</b> В класс <b>game_object</b> добавлены универсальные функции для чтения/записи значения с плавающей запятой по заданному смещению в объекте актора и аналогичную для целого значения пока только на чтение:<br>
<br>
<ul><li><b>local res = db.actor:get_actor_float(pos)</b> -- получение 4-х байтового числа с плавающей запятой по заданному смещению из объекта актора.<br>
</li><li><b>local res = db.actor:get_actor_int(nil, pos)</b> -- получение 4-х байтового целого по заданному смещению из объекта актора. Первый аргумент - заглушка, должен быть всегда nil.<br>
</li><li><b>db.actor:set_actor_float(nil, v, pos)</b> -- запись 4-х байтового числа с плавающей запятой по заданному смещению в объект актора. Первый аргумент - заглушка, всегда nil.</li></ul>

Все эти функции применяются для <b>game_object</b>, но годятся строго для объекта актора! Не пытайтесь использовать их для других объектов.<br>
<br>
<h3>известные смещения</h3>
<ul><li><b>db.actor:get_actor_float(900)</b> -- уровень шума. В сущности, это то, что слышит сам актор, поскольку это число обновляется во внутреннем колбеке на звук актора с проверкой, что это он же сам и шумит. При этом, если звуков нет, то число начинает непрерывно уменьшаться со скоростью 0.3/сек. Таким образом, негативное значение измеряет время тишины, а позитивное - это уровень шумности самого актора. И это именно то число, которое отображается на индикаторе.</li></ul>

<h2>расширения для работы с оружием</h2>

<b>[ТЧ]</b> Добавлены методы game_object для работы с объектами оружия:<br>
<br>
<ul><li><b>local res = wpn:get_wpn_int(nil, pos)</b> -- получение целого 4-х байтового числа по заданному смещению для любого типа оружия, т.е. для объектов, производных от <b>CWeapon</b>.<br>
</li><li><b>wpn:set_wpn_int(pos, value)</b> -- аналогично установка целого 4-х байтового числа по заданному смещению<br>
</li><li><b>value = wpn:get_wpn_float(pos)</b> -- чтение 4-х байтового&nbsp;числа с плавающей запятой (float) по смещению pos<br>
</li><li><b>wpn:set_wpn_float(nil, value, pos)</b> -- запись float по смещению pos</li></ul>

Пояснение: Этими функциями можно пользоваться для всех типов стволов также и для получения/уставноки полей сверх базовых из <b>CWeapon</b>. Это возможно потому, что базовый объект <b>CWeapon</b> расположен в любом производном по нулевому смещению (что в иных случаях может быть и нет так). Однако, надо понимать, что при этом можно для неправильного типа объекта вылезти за его границы. В общем, надо сначала убедиться, что тип объекта правильный. В частности для этого предназначены функции <b>is_weapon</b> и <b>is_weapon_gl</b>.<br>
<br>
<h2>телепорт объектов</h2>

<b>[ТЧ]</b> В класс <b>alife_simulator</b> добавлен метод <b>teleport_object</b>, предназначенный для телепорта объектов. Работает между уровней и для произвольного типа объектов (живых, физических). Пользоваться так:<br />
<b>alife():teleport_object("", new_pos, new_lvid, new_gvid, object_id)</b>

первый аргумент - заглушка. Должен быть строкой с произвольным значением.<br>
<br>
<h2>правки для исправления бага с визуалом актора</h2>

<b>[ТЧ]</b> Внесены изменения на предмет правки бага с визуалом актора:<br>
<br>
<ol><li>Работа внутреннего колбека на попадание брони в рюкзак деактивирована. Ранее там была установка дефолтового визуала актора и выключение ПНВ. Это некорректно, поскольку броня может попадать в рюкзак не только после удаления из слота, но и другими путями.<br>
</li><li>Для компенсации вырезанного поведения в класс game_object добавлен метод set_actor_visual. Работает только для актора. Использование простое: <b>cact:set_actor_visual("actors\\monolit\\stalker_mo_mask")</b></li></ol>

Идея заключается в том, что в колбеках на попадание предмета в рюкзак и выбрасывание из инвентаря надо проверить, не изменился ли костюм в слоте с последнего раза. Если изменился, то надо установить визуал этой функцией в соответствии с костюмом. Если не изменился, то ничего делать не надо.<br>
<br>
Примечания:<br>
<ul><li>Возможно, должны быть ещё точки проверки, кроме колбеков на дроп и попадание в рюкзак. По идее это все способы, какими может исчезнуть костюм из слота: снять в рюкзак либо выкинуть прямо из слота, но вдруг я чего-то не додумал.<br>
</li><li>Пока не ясно, как это будет работать и насколько устойчиво. Опять же, вытащена штатная функция движка, которой меняется и должен меняться визуал, но кто его знает.<br>
</li><li>Надевание скриптово обрабатывать не надо. Вроде как движок с этим сам неплохо справляется.<br>
</li><li>Не вполне очевидно, что делать в ситуации, когда один костюм заменяется другим. В этот момент отрабатывает движковая смена визуала, а с другой стороны происходит снятие старого костюма и вызов колбека на снятие. Что происходит раньше, что позже - разбирайтесь и разруливайте сами.<br>
</li><li>Работа встроенного ПНВ таким образом подпорчена. Теперь он не отключается при снятии костюма вовсе (вручную по идее должен отключаться, как и раньше).</li></ul>

<h2>Консольные команды для настройки худа оружия</h2>

Режим настройки худа оружия, известный по билдам, вырезан в релизе не полностью. По крайней мере в ТЧ остался код обработки нажатий и глобальная переменная с режимом настройки. Убрали только консольные команды для установки режима, так что он всегда "0" т.е. не активен.<br>
<br>
<b>[ТЧ]</b> Возвращены две команды консоли - <b>hud_adjust_mode</b> и <b>hud_adjust_value</b>:<br>
<br>
<b>hud_adjust_mode</b> <номер режима 0 - 5><br>
<br>
режимы:<br>
<ul><li>0 - не делать ничего<br>
</li><li>1 - подгонка худа в режиме прицеливания<br>
</li><li>2, 5 - подгонка позиции партиклов стрельбы для разных режимов. Не работает!<br>
</li><li>3 - подгонка позиции гранаты. По идее должна работать, но я не знаю как именно.<br>
</li><li>4 - подгонка позиции партиклов гильз. Не работает!</li></ul>

Как пользоваться. Команда в движке завязана на жёстко заданные клавиши. в случае с настройкой позиции оружия: <b>ASDW</b> - перемещение, <b>QE</b> - ближе/дальше, <b>JKLI</b> - вращение, <b>P</b> - скинуть полученные координаты в лог. Удерживаете мышой режим прицеливания и настраиваете ствол клавишами. Потом жмёте "P" и в логе смотрите получившиеся настройки ствола. Для других режимов используются те же клавиши. На время настройки имеет смысл отбиндить штатное назначение, поскольку конфликтует.<br>
<br>
<b>hud_adjust_value</b> <чувствительность настройки в диапазоне 0.0 - 1.0>. Это приращение соответствующего значения за одно нажатие клавиши. По моим ощущениям осмысленными являются достаточно маленькие значения типа 0.01.<br>
<br>
Есть один побочный эффект, который надо компенсировать скриптом. Режим запоминается в настройках, так что надо его принудительно скриптом выставлять при старте игры в ноль, иначе у игроков начнутся непонятки.<br>
<br>
<h2>Проверка на нулевой аргумент в <b>alife():release()</b></h2>

В релизе движка имеется функция удаления объектов:<br>
<b>alife():release(<серверный объект>, <неиспользуемый логический аргумент>)</b>
функция работает таким образом, что при передаче первым аргументом значения <b>nil</b> такая ситуация не обрабатывается, что приводит к генерации внутреннего исключения, которое по непонятным причинам не вызывает обрушения, а вместо этого приводит к зависанию внутренних подсистем игры с непонятными последствиями.<br>
<br>
<b>[ТЧ]</b> В метод <b>release</b> класса <b>alife_simulator</b> добавлена проверка, что передаваемый объект для удаления не равен <b>nil</b>. Теперь реакция будет однозначная - вылет с логом, в котором будет внятное сообщение.<br>
<br>
<h2>Глобальная функция для выхода из игры с сообщением в логе</h2>

<b>[ТЧ]</b> Добавлена глобальная функция <b>fail(string <сообщение>)</b>, которая останавливает игру и выводит <сообщение> в лог. Для останова игры использована внутренняя функция, которая используется для тех-же целей самой игрой в различных проверках.<br>
<br>
<h2>Получение веса барахла</h2>

<b>[ТЧ]</b> Добавлен метод <b>get_weight</b> класса <b>game_object</b>, который работает только для актора и позволяет получить суммарную массу вещей в инвентаре. Это то число, которое отображается в окне инвентаря. Польза функции в том числе в том, что она автоматически учитывает массу патронов в пачках и в магазинах стволов.<br>
<br>
<h2>Дополнительные средства работы с инвентарными ящиками</h2>

<b>[ТЧ]</b> Добавлены методы для перебора предметов в ящиках:<br>
<br>
<b>inv_box_count</b> -- получение количества предметов в ящике<br>
<b>object_from_inv_box</b> -- получение предмета по индексу (нумерация от нуля)<br>
<br>
<b>[ТЧ]</b> <b>open_inventory_box(box)</b> -- метод актора. Открыть диалог с инвентарём ящика. Расстояние до ящика роли не играет, но ящик должен быть в онлайне.<br>
<br>
<b>[ТЧ]</b> Добавлен колбек на взятие в инвентарный ящик. Колбек устанавливается для ящика, код 151.<br>
<br>
<h2>Функция лечения ран</h2>

<b>[ТЧ]</b> Добавлена функция уменьшения скорости кровотечения:<br>
<br>
<b>npc:heal_wounds(<на сколько уменьшить>)</b>

Механизм кровотечения в движке сталкера не так прост, как может показаться. Внутри имеется полная информация о каждой ране (т.е. степень повреждения для каждой кости). Соответственно, степень кровотечения, которую мы получаем функцией <b>bleeding</b>, представляет собой некое вычисленное значение, которое суммируется из всех ран по всем костям. Внутри имеется также и функция для изменения кровотечения, но хитрая. С её помощью можно только уменьшить кровотечение, хотя она внутри и называется <b>change_bleeding</b>. Она уменьшает раны (все разом) а также совсем их убирает, когда они уменьшаются до нуля. Посему, экспортировав эту функцию, я решил и назвать её соответственно (<b>heal_wounds</b>/лечить, а не <b>change_bleeding</b>), дабы не было непоняток с её истинным назначением.<br>
<br>
<h2>Получение владельца holder-а</h2>

<b>[ТЧ]</b> Добавлена функция для получения владельца машины или станкового оружия:<br>
<br>
<b>holder:get_holder_owner()</b> - возвращает <b>game_object</b> или <b>nil</b>, если владелец отсутствует. Работает для классов, унаследованных от <b>CCustomHolder</b>, каковыми являются машины и станковое оружие.<br>
<br>
<h2>Получение двухбайтового целого по смещению в объекте актора</h2>

<b>[ТЧ]</b> Добавлен метод для получения двухбайтового числа по заданному смещению в объекте актора<br>
<br>
<b>local value = db.actor:get_actor_int16(nil, <смещение>)</b> - возвращает число в диапазоне 0-65535<br>
<br>
Функция допускает широкое использование, хотя двухбайтовые значения и редко встречаются в объектах. В основном, функция была добавлена для получения id холдера (т.е. текущей машины, в которой сидит ГГ, или станкового пулемёта). Это делается так:<br>
<br>
<b>local car_id = db.actor:get_actor_int16(nil, 1240)</b>

если ГГ не в машине, то вернёт 65535<br>
<br>
<h2>Манипуляция моделью худа</h2>

<ul><li>Установка видимости костей худа</li></ul>

<b>[ТЧ]</b> Добавлена функция для скрытия/показа определённых костей визуала худа:<br>
<b>hud_item:set_hud_bone_visible(<имя кости>)</b>

<blockquote>Предмет должен быть активным предметом, т.е. не только быть в активном слоте, но и чтобы худ был виден.</blockquote>

<ul><li>Получение позиции кости худа по аналогии с функцией для обычной модели</li></ul>

<b>local pos = hud_item:get_hud_bone_pos(bone_name)</b>

<h2>Фикс функции disable_info_portion</h2>
<b>[ТЧ]</b> В начале функции вставлена проверка, чтобы при отсутствии нужной инфопорции функция не делала вообще ничего. Смысл фикса в удалении ненужных действий, в частности обновления диалоговых окон. Без этого фикса постоянно сбрасывается позиция скроллинга списка ответов в диалоге разговора, из-за чего становится проблематично добавить больше вариантов ответов, чем влезает в видимую область окна.<br>
<br>
<h2>Функция назначения <b>story id</b></h2>

<b>[ТЧ]</b> Добавлена функция для одновременного назначения story id и его регистрации в реестре сюжетных идентификаторов. Подробнее:<br>
<ul><li>имя функции <b>assign_story_id</b>, добавлена в виде метода класса <b>alife_simulator</b>
</li><li>использовать так<br>
<b>alife():assign_story_id(nil, nil, object_id, sid)</b></li></ul>

где <b>object_id</b> - идентификатор объекта<br>
<br>
<b>sid</b> - назначаемый story id. Естественно, надо прописать этот sid заранее в конфигах и дать ему символьный идентификатор, так что здесь можно использовать его идентификатор из таблицы <b>story_ids</b>. Что-то типа <b>story_ids.my_new_cool_sid</b>

<b>функция предназначена исключительно для использования сразу после спавна таким образом:<br></b><pre><code><br>
local sim = alife()<br>
local sobj = sim:create("stalker", pos, lvid, gvid)<br>
sim:assign_story_id(nil, nil, sobj.id, story_ids.my_new_cool_sid)</code></pre>
Ни в какой другой момент её вызывать не надо. Далее <b>sid</b> запомнится и будет вести себя как обычно. По идее, сразу должна заработать и логика, которая завязана на <b>sid</b>.<br>
<br>
<h2>Функции изменения отношения между NPC в оффлайне</h2>
<b>[ТЧ]</b> Добавлены функции для изменения отношений между неписями через ID. Соответственно, их можно использовать и для серверных объектов, в том числе сразу после создания, не дожидаясь выхода в онлайн.<br>
<ul><li>установка отношения (метод актора) <b>actor:set_goodwill_ex(who_id, to_whom_id, goodwill)</b>
</li><li>изменение отношения на заданное значение (метод актора) <b>actor:change_goodwill_ex(who_id, to_whom_id, goodwill_change)</b>
</li><li>получение текущего отношения (глобальная функция) <b>GetGoodwill(who_id, to_whom_id)</b></li></ul>

Примечания:<br>
<br>
Поскольку функции реализованы достаточно уродливо, то предпочтительнее использовать скриптовые обёртки, добавляющие вменяемые функции в пространство имён <b>relation_registry</b> по аналогии с уже там имеющимися:<br>
<pre><code>function relation_registry.get_goodwill(who_id, to_whom_id)<br>
return GetGoodwill(who_id, to_whom_id)<br>
end<br>
<br>
function relation_registry.set_goodwill(who_id, to_whom_id, goodwill)<br>
return db.actor:set_goodwill_ex(who_id, to_whom_id, goodwill)<br>
end<br>
<br>
function relation_registry.change_goodwill(who_id, to_whom_id, goodwill_change)<br>
return db.actor:change_goodwill_ex(who_id, to_whom_id, goodwill_change)<br>
end</code></pre>

Соответственно их использование:<br>
<br>
<b>relation_registry.get_goodwill(who_id, to_whom_id)</b><br>
<b>relation_registry.set_goodwill(who_id, to_whom_id, goodwill)</b><br>
<b>relation_registry.change_goodwill(who_id, to_whom_id, goodwill_change)</b>

Есть одно ограничение, связанное с реализацией. Использовать эти функции можно только после появления онлайнового актора. Думаю впрочем, это не критично, просто надо об этом помнить.<br>
<br>
<h2>Свойство <b>satiety</b> для изменения/получения сытости</h2>

<b>[ТЧ]</b> в классе <b>game_object</b> добавлено свойство <b>satiety</b> для изменения/получения сытости. Использование:<br>
<ul><li>получаем текущее значение <b>db.actor.satiety</b>
</li><li>меняем как обычно для свойств (значение на запись означает приращение) <b>db.actor.satiety = 0.3</b> -- увеличить на 0.3</li></ul>

Применимо только к актору. Для остальных объектов вылета не вызовет, но и ничего не сделает: получение вернёт всегда 0, установка будет проигнорирована. Значение сытости имеет предел сверху 1.0, т.е. больше единицы не записать. Предела снизу нет.<br>
<br>
Примечания относительно работы алгоритма голода/сытости:<br>
<br>
<ul><li>значение сытости постоянно уменьшается со скоростью, заданной параметром "satiety_v" из секции "actor_condition". Скорость задаётся относительно секунд игрового времени.<br>
</li><li>на сытость никак не влияют арты, костюм и вообще что угодно, кроме этого постоянного уменьшения и съеденной еды.<br>
</li><li>по достижению нулевого и ниже значения начинает уменьшаться здоровье со скоростью заданной параметром "satiety_health_v" из той же секции "actor_condition". При положительной сытости здоровье напротив увеличивается с той же  скоростью. Обращаю внимание, что скорость увеличения или уменьшения здоровья ни от чего не зависит, только меняет знак соответственно знаку сытости .<br>
</li><li>Как увеличение так и уменьшение здоровья происходит только при отсутствии кровотечения.<br>
</li><li>зелёный индикатор голода появляется при значении сытости < 0.5</li></ul>

<h2>Фикс некорректного переключения гранат</h2>
<b>[ТЧ]</b> Движок некорректно переключает гранаты, если их больше двух разновидностей в инвентаре. Данный фикс полностью отключает движковое переключение. Для исправления требуется скриптовая реализация переключения.<br>
<br>
<h2>Управление "торгуемостью" предметов</h2>

<b>[ТЧ]</b> Добавлено управление "торгуемостью" предметов. Это включает в себя фикс функции наполнения окна торговли и дополнительный глобальный флаг активации фильтрации. Кроме того использованы ранее добавленные возможности по чтению и установке значения в инвентарном предмете.<br>
<br>
1. Внесено изменение во внутреннюю функцию наполнения окна торговли. Туда добавлена проверка двух флажков, которые хранятся в объекте предмета. Использовано поле флагов размеров в два байта по смещению 132 от начала объекта инвентарного предмета, в котором имелись несколько неиспользованных бит начиная с 12-го бита (считая от нуля). Флажки такие:<br>
<ul><li>бит 12 - сделать предмет безусловно продаваемым<br>
</li><li>бит 13 - сделать предмет безусловно непродаваемым (будет проверяться только если не установлен бит 12)</li></ul>

Вот функции обёртки для работы с этими флагами:<br>
<br>
<pre><code>function set_item_undoubtfully_tradable(item, value)<br>
item:set_inventory_item_int16(132, flags16():assign(item:get_inventory_item_int16(nil, 132)):set(4096, value):get())<br>
end<br>
function set_item_undoubtfully_untradable(item, value)<br>
item:set_inventory_item_int16(132, flags16():assign(item:get_inventory_item_int16(nil, 132)):set(8192, value):get())<br>
end</code></pre>

2.Кроме того, все эти проверки будут выполняться только если установлен глобальный флаг активности проверок. Для установки и снятия этого флага также добавлены две глобальные функции:<br>
<ul><li><b>set_trade_filtration_on()</b> -- включить режим фильтрации<br>
</li><li><b>set_trade_filtration_off()</b> -- отключить режим фильтрации</li></ul>

Итого, для активации фильтрации предметов надо включить глобальный флаг, используя <b>set_trade_filtration_on()</b>, затем перебрать все предметы в инвентаре и для каждого включить либо флаг 12, либо флаг 13, либо не включать никакой. Если фильтрация отключена глобально или оба флага сброшены, то для предмета будет использовано движковое условие, взятое из конфига торговца.<br>
<br>
<h2>Получение/установка значений по смещению для инвентарного предмета</h2>
<ul><li>get_go_float<br>
</li><li>set_go_float<br>
</li><li>get_go_int<br>
</li><li>set_go_int<br>
</li><li>get_go_int16<br>
</li><li>set_go_int16<br>
</li><li>set_go_shared_str</li></ul>

<ul><li>get_inventory_item_float<br>
</li><li>set_inventory_item_float<br>
</li><li>get_inventory_item_int<br>
</li><li>set_inventory_item_int<br>
</li><li>get_inventory_item_int16<br>
</li><li>set_inventory_item_int16<br>
</li><li>set_inventory_item_shared_str</li></ul>

<h2>Получение/установка 64-х разрядного счётчика из объекта класса <b>game.CTime</b></h2>

Время в движке измеряется 64-х разрядным счётчиком, считающим миллисекунды с ...<br>
Штатным образом объект класса <b>game.CTime</b> позволяет получить его значение с помощью метода <b>get</b> только в виде компонент: год, месяц, день, час, секунды, миллисекунды. Соответственно, задать значение объекта (с помощью методов <b>set</b>, <b>setHMSms</b>, <b>setHMS</b>) также можно только через задание этих компонент. Это удобно для манипуляций значениями, однако при записи/чтении в/из нетпакета приходится разбирать объект на компоненты, сохранять много значений по отдельности и потом при загрузке их читать и ими задавать значение. Это неудобно, поэтому добавлены функции для получения и записи объекта <b>CTime</b> в виде двух 32-х разрядных значений, которые являются соответственно старшей и младшей частями полного счётчика.<br>
<br>
Использование:<br>
<ul><li><b>local lv, bv = time:get_value()</b> -- получить младшую и старшую части счётчика<br>
</li><li><b>time:set_value(lv, gv)</b> -- установить значение объекта из компонент</li></ul>

Примечание: полученные таким образом компоненты предназначены исключительно для сохранения и восстановления значения времени из нетпакета. Никак иначе их использовать не рекомендуется.<br>
<br>
<br>
<h2>Расширения для матричных операций</h2>

В билдах класс <b>matrix</b> обладал полным набором матричных и векторных операций. В релизе почти все они были убраны.<br>
<br>
<b>[ТЧ]</b> Добавлены следующие методы, делающие класс <b>matrix</b> несколько более полезным:<br>
<ul><li><b>m:transpose()</b> -- транспонировать матрицу<br>
</li><li><b>m:mul_43(v)</b> -- умножить на вектор. Результат замещает матрицу-аргумент, 4-й компонент вектора принимается равным единице.</li></ul>

<h2>Управление прожектором</h2>

<b>[ТЧ]</b> Добавлены функции для управления состоянием и получения состояния прожектора.<br>
<ul><li><b>proj:projector_on()</b> -- включить<br>
</li><li><b>proj:projector_off()</b> -- выключить<br>
</li><li><b>proj:switch_projector()</b> -- переключить<br>
</li><li><b>proj:projector_is_on()</b> -- узнать состояние</li></ul>

<h2>Возможность регистрации различных команд консоли</h2>

Эти возможности подразумевают использование не непосредственно в игре, а для программиста. Дают возможность добавлять разные команды консоли. Одно из применений - возможность сохранять настройки в файле <b>user.ltx</b>

<b>[ТЧ]</b> Добавлены макросы<br>
<br>
<ul><li><b>REGISTER_CC_INT2</b>   - регистрация команды, связанной с целочисленным параметром<br>
</li><li><b>REGISTER_CC_FLOAT2</b> - регистрация команды, связанной с числом с плавающей запятой<br>
</li><li><b>REGISTER_CC_FLAG</b>   - регистрация команды, связанной с двоичным флагом</li></ul>

Новые команды добавляются в файле <b>console_commands_reg_fix.asm</b>. Подробнее:<br>
<br>
Регистрация команды, меняющей целочисленное значение по заданному глобальному адресу:<br>
<br>
<b>REGISTER_CC_INT2   global_var, "command_name", 3, 10</b>

здесь<br>
<ul><li><b>global_var</b> - метка глобальной 32-х разрядной переменной<br>
</li><li><b>"command_name"</b> - имя команды<br>
</li><li><b>3 и 10</b> - соответственно нижний и верхний пределы значений.</li></ul>

Регистрация команды, меняющей значение с плавающей запятой по заданному глобальному адресу:<br>
<br>
<b>REGISTER_CC_FLOAT2 global_var, "command_name", 0.1, 0.5</b>

здесь<br>
<ul><li><b>global_var</b> - метка глобальной переменной в формате float32<br>
</li><li><b>"command_name"</b> - имя команды<br>
</li><li><b>0.1 и 0.5</b> - соответственно нижний и верхний пределы значений.</li></ul>

Регистрация команды, меняющей заданный бит переменной по заданному глобальному адресу:<br>
<br>
<b>REGISTER_CC_FLAG   global_var, mask, "command_name"</b>

здесь<br>
<ul><li><b>global_var</b> - метка глобальной 32-х разрядной переменной<br>
</li><li><b>mask</b> - число, задающее маску, которая задаёт конкретный бит или группу битов внутри числа<br>
</li><li><b>"command_name"</b> - имя команды</li></ul>

<h2>Увеличение игрового времени</h2>

<b>[ТЧ]</b> Добавлена функция <b>level.advance_game_time(dt)</b>, позволяющая увеличить игровое время на заданное количество миллисекунд.<br>
<br>
<h2>Отсоединение окна от родительского</h2>

Иногда имеется проблема, связанная с тем, что тяжело сохранить ссылку на родительское окно пользовательского окна. Такая ситуация иногда возникает при размещении элементов на движковых диалогах торговли, PDA, инвентаря и т.п. Данная правка предназначена для безболезненного отсоединения от родителя без необходимости иметь ссылку на родительское окно и вообще необходимости знать, есть ли родительское окно.<br>
<br>
<b>[ТЧ]</b> В класс <b>CUIWindow</b> добавлен метод <b>DetachFromParent</b>, который эквивалентен по действию методу <b>DetachChild</b>, но не требует при этом иметь ссылку на объект родительского окна. Если родительского окна нет, то функция ничего не делает.<br>
<br>
<h2>Универсальный хак для <b>CActorCondition</b></h2>

Ряд параметров актора хранятся не прямо в объекте актора, а в специальном объекте типа <b>CActorCondition</b>, на который в объекте актора хранится только указатель. Соответственно, для извлечения значений оттуда нужен специальный хак.<br>
<br>
<b>[ТЧ]</b>
<ul><li><b>get_actor_condition_float</b> - получение float по смещению в<br>
</li><li><b>set_actor_condition_float</b> - запись float по смещению</li></ul>

Использование:<br>
<br>
<b>local val = actor:get_actor_condition_float(shift)</b><br>
<b>actor:set_actor_condition_float(nil, value, shift)</b>

<h2>Манипуляции костями скелета мировой модели и худа</h2>

<b>[ТЧ]</b>
<ul><li><b>get_wpn_bone_id(bone_name)</b> - получить индекс кости по её имени для объекта оружия, получаем индекс кости<br>
</li><li><b>get_hud_bone_id(bone_name)</b> - получить индекс кости по её имени для худа объекта, получаем индекс кости<br>
</li><li><b>get_hud_bone_pos(bone_name)</b> - получить положение кости худа по её имени, получаем vector<br>
</li><li><b>get_wpn_bone_visible(bone_name)</b> - получить видимость кости мировой модели объекта оружия (возвращает 1/0)<br>
</li><li><b>set_wpn_bone_visible(bone_name, 1|0)</b> - установить видимость кости мировой модели объекта оружия<br>
</li><li><b>set_hud_bone_visible(bone_name, 1|0)</b> - установить видимость кости худа объекта<br>
</li><li><b>get_bone_visible(bone_name)</b> - получить видимость кости мировой модели объекта (возвращает 1/0)<br>
</li><li><b>set_bone_visible(bone_name, 1|0)</b> - установить видимость кости объекта<br>
</li><li><b>play_hud_animation(animation_name, mix_in)</b> - проиграть анимацию худа (анимация должна присутствовать в модели). Второй аргумент (true|false) определяет плавность перехода<br>
</li><li><b>ini_file</b> object:get_visual_ini()<b>- получить внутренний конфиг модели. Это конфиг, который можно редактировать только в Actor Editor. Многие объекты хранят там свои настройки (машины, прожектора и т.п.)</li></ul></b>


<h2>Обновление окна инвентаря</h2>

<b>[ТЧ]</b> Добавлен метод <b>invalidate_inventory</b> класса <b>game_object</b> для обновления окна инвентаря. Может потребоваться после некоторых операций с перемещением предметов между слотами, поясом, рюкзаком. Использование:<br>
<br>
<b>actor:invalidate_inventory()</b>


<h2>Доступ к функции трассировки пересечения луча и геометрии</h2>

<b>[ТЧ]</b> Добавлен интерфейс к  внутренней функции <b>RayPick</b>, которая может проверить пересекается ли заданная произвольная прямая с какой-либо геометрией на уровне. Поскольку функция имеет много параметров, то подходящего прототипа для полноценной регистрации не нашлось. Поэтому пришлось передавать входные данные и получать результаты через глобальные переменные. Теперь подробнее.<br>
Входными аргументами функции являются: точка, откуда начинаем трассировку, единичный вектор направления трассировки, диапазон трассировки, флаги геометрии, игнорируемый объект. Выходные результаты это логическое значение успешности поиска, расстояние до найденной точки пересечения, объект, которому принадлежит найденная точка.<br>
<br>
вектор направления трассировки задаётся так:<br>
<b>db.actor:set_vector_global_arg_1(direction)</b>

точка, откуда начинаем трассировку задаётся так:<br>
<b>db.actor:set_vector_global_arg_2(position)</b>

диапазон трассировки задаётся так:<br>
<b>set_float_args_12(range, 0)</b> -- второе значение - это заглушка<br>
<br>
флаги, задающие фильтр геометрии для поиска, задаются так<br>
<b>set_int_arg1(flags)</b>

игнорируемый объект задаётся так<br>
<b>db.actor:set_object_arg_1(obj)</b> -- аргумент, клиентский объект или nil<br>
<br>
собственно выполнение запроса по заданным параметрам выполняется так:<br>
<b>local res = level.perform_ray_pick_query()</b>

получение расстояния до найденной точки:<br>
<b>local res_dist = level.get_ray_pick_dist()</b> -- если поиск не был успешен (вызов level.perform_ray_pick_query() вернул false), то это будет в точности равно ранее заданному значению диапазона поиска.<br>
<br>
получение объекта:<br>
<b>local res_obj = level.get_ray_pick_obj()</b> -- тип - клиентский объект или nil<br>
<br>
элемент треугольника геометрии, или номер кости клиентского объекта:<br>
<b>local element = level.get_ray_pick_element()</b> -- при неудаче вернёт -1<br>
<br>
<h2>Функции получения стандартных окон</h2>

<b>[ТЧ]</b> Добавлены функции получения стандартных окон:<br>
<pre><code>local wnd = level.get_inventory_wnd() -- инвентарь<br>
local wnd = level.get_pda_wnd() -- PDA<br>
local wnd = level.get_talk_wnd() -- окно диалога<br>
local wnd = level.get_car_body_wnd() -- инвентарь трупа или ящика<br>
local wnd = level.get_trade_wnd() -- окно торговли<br>
</code></pre>

<h2>Функция получения собеседника во время разговора или торговли</h2>

<b>[ТЧ]</b> Добавлена функция получения клиентского объекта собеседника. Пользоваться можно только во время разговора или торговли.<br>
<br>
<b>local npc = level.get_second_talker()</b>

<h2>Функция проверки пробиваемости материала геометрии</h2>

<b>[ТЧ]</b> Добавлена функция проверки пробиваемости материала геометрии<br>
<br>
element - треугольник геометрии полученный функцией <b>level.get_ray_pick_element()</b>.<br>
<b>local shootfactor = level.get_tri_shootfactor(nil, element)</b> -- первый параметр строка, не используется.<br>
Вернёт float от 0.0 до 1.0:<br>
0. - не пробиваемый, 1. - полностью пробиваемый, пуля пролетает без задержки (кусты, силовое поле для актора и т.д.).<br>
<br>
<br>
<h2>Функция получения флагов материала геометрии</h2>

<b>[ТЧ]</b>  Добавлена функция получения флагов материала геометрии.<br>
<br>
<b>local flags = level.get_tri_flags(element)</b>

Описание флагов в виде lua кода, копируем в начало скрипта.<br>
<pre><code>local mtlFlags = {<br>
flBreakable	= 1, 		-- 0 	разрушаемый<br>
--  flShootable0 	= 2, 		-- 1 	простреливаемый, движком не используется (использовался наверно в старых билдах)<br>
flBounceable	= 4,		-- 2 	Может ли пуля нерикошетить? (0 - рикошетит, 1 - нерикошетит)<br>
flSkidmark		= 8,		-- 3 	Оставляет ли тормозной след?<br>
flBloodmark	= 16, 		-- 4 	оставляет ли кровь?<br>
flClimable		= 32,		-- 5 	невидимая лестница<br>
--  flWalkOn		= 64, 		-- 6 	obsolette<br>
flPassable		= 128, 		-- 7 	проходимый для физ. объектов<br>
flDynamic		= 256,		-- 8 	динамический объект<br>
flLiquid		= 512, 		-- 9 	жидкость (вода)<br>
flSuppressShadows	= 1024,		-- 10 	заглушает тени<br>
flSuppressWallmarks= 2048,		-- 11 	заглушает отметены от пуль<br>
flActorObstacle	= 4096, 	-- 12 	препятствие (силовое поле) для актора<br>
flInjurious	= 268435456,	-- 28 	flInjurious = fInjuriousSpeed &gt; 0.f -- отбирает ли здоровье?<br>
flShootable 	= 536870912,	-- 29 	не простреливаемый<br>
flTransparent	= 1073741824,	-- 30 	непрозрачный<br>
flSlowDown		= 2147483648 	-- 31 	flSlowDown = (fFlotationFactor&lt;1.f) -- замедление движение<br>
}			-- 0 - false (нет), 1 - true (да)<br>
</code></pre>
Пример использования.<br>
<pre><code>local flags = level.get_tri_flags(element)<br>
if bit_and(flags, mtlFlags.flBounceable) == 0 then -- пуля рикошетит<br>
else -- пуля не рикошетит<br>
end<br>
</code></pre>